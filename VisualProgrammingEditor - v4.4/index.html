
  <!DOCTYPE html>
  <html lang="en" xmlns = "http://www.w3.org/1999/xhtml">
  <head>
    <script src="https://unpkg.com/gojs@2.2.13/release/go.js"></script>
    <script src="generator.js"></script>
    <script id="code">

    function init() {

      const $ = go.GraphObject.make;  // for conciseness in defining templates

      var orangegrad = $(go.Brush, "Linear", { 0: "rgb(254, 201, 0)", 1: "rgb(254, 162, 0)" });
      var greengrad = $(go.Brush, "Linear", { 0: "#98FB98", 1: "#9ACD32" });
      var bluegrad = $(go.Brush, "Linear", { 0: "#B0E0E6", 1: "#87CEEB" });
      var yellowgrad = $(go.Brush, "Linear", { 0: "rgb(255, 255, 0)", 1: "rgb(230, 230, 0)" });
      var whitegrad = $(go.Brush, "Linear", { 0: "#F0F8FF", 1: "#E6E6FA" });

      myDiagram =
        $(go.Diagram, "myDiagramDiv",  // create a new Diagram in the HTML DIV element "myDiagramDiv"
          {
            "undoManager.isEnabled": true,
            "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
					  initialAutoScale: go.Diagram.Uniform,
					  initialContentAlignment: go.Spot.Left
          });

      // when the document is modified, add a "*" to the title and enable the "Save" button
      myDiagram.addDiagramListener("Modified", e => { //name "Modified" is built-in
        var button = document.getElementById("saveModel");
        if (button) button.disabled = !myDiagram.isModified;
      });

      // creates relinkable Links that will avoid crossing Nodes when possible and will jump over other Links in their paths
      myDiagram.linkTemplate =
        $(go.Link,
          {
            routing: go.Link.AvoidsNodes,
            curve: go.Link.JumpOver,
            //corner: 3,
            relinkableFrom: true, relinkableTo: true,
            selectionAdorned: false, // Links are not adorned when selected so that their color remains visible.
            shadowOffset: new go.Point(0, 0), shadowBlur: 5, shadowColor: "red"
          },
          new go.Binding("isShadowed", "isSelected").ofObject(),
          $(go.Shape,
            { name: "SHAPE", strokeWidth: 2, stroke: "blue", strokeDashArray:  [3,2]},
            new go.Binding("stroke", "fromNode", function(node) { 
              if(node.name == "blocks")
              {
                return "purple";
              }
            }).ofObject(),
            new go.Binding("strokeDashArray", "fromNode", function(node) { 
              if(node.name == "blocks")
              {
                return 0;
              }
            }).ofObject(),
            new go.Binding("strokeWidth", "fromNode", function(node) { 
              if(node.name == "blocks")
              {
                return 4;
              }
            }).ofObject()),
          $(go.Shape,
            { toArrow: "Standard"},
            { name: "SHAPE", strokeWidth: 2, stroke: "blue" },
            new go.Binding("stroke", "fromNode", function(node) {
              if (node.name == "blocks") {
                return "purple"
              }
            }).ofObject(),
            new go.Binding("toArrow", "fromNode", function(node) {
              if (node.name == "blocks") {
                return null;
              }
            }).ofObject())
          );

        myDiagram.linkTemplateMap.add("Reversed",
            $(go.Link,
              new go.Binding("isShadowed", "isSelected").ofObject(),
              {selectionAdorned: false, // Links are not adorned when selected so that their color remains visible.
              shadowOffset: new go.Point(0, 0), shadowBlur: 10, shadowColor: "red"},
              $(go.Shape, { strokeWidth: 4, stroke: "darkgreen" }),
              $(go.Shape, { fromArrow: "Backward" }),
            )
          );
      // define some common property settings
      function nodeStyle() {
        return [new go.Binding("isShadowed", "isSelected").ofObject(),
        {
          selectionAdorned: false,
          shadowOffset: new go.Point(0, 0),
          shadowBlur: 15,
          shadowColor: "blue",
        }];
      }

      function nodeFunctionShapeStyle() {
        return {
          name: "NODESHAPE",
          fill: "lightgray", //default color
          stroke: "darkslategray",
          desiredSize: new go.Size(80, 50),
          strokeWidth: 2
        };
      }

      function functionStyle(shapeColor, functionName) {
        return [
          nodeStyle(),
          $(go.Shape, {figure: "Rectangle"}, nodeFunctionShapeStyle(),
            { fill: shapeColor }
          ),
          $(go.TextBlock, functionName, textStyle(),
            new go.Binding("text","text").makeTwoWay()
          )
        ]
      }

      function nodeFunctionStyle(shapeColor, functionName) {
        return [
          functionStyle(shapeColor, functionName),
          $(go.Shape, "Rectangle", portStyle(true), 
            { portId: "in", opacity: 0.3,alignment: new go.Spot(0, 0.5), alignmentFocus: go.Spot.Left ,desiredSize: new go.Size(20, 50)}
          )
        ];
      }

      function groupFunctionStyle(shapeColor, functionName) { 
        return [
          go.Panel.Auto,
          {
            isSubGraphExpanded: false,  // only show the Group itself, not any of its members
            ungroupable: true
          },
          functionStyle(shapeColor, functionName)
        ]
      }

      function node_Var_ShapeStyle() {
        return {
          name: "NODEVARSHAPE",
          fill: "lightgray",
          stroke: "darkslategray",
          desiredSize: new go.Size(80, 20),
          strokeWidth: 2
        };
      }

      function textStyle() {
        return {
          font: "bold 11pt Lato, Helvetica, Arial, sans-serif",
          stroke: "#000000"
        }
      }

      function portStyle(input) {
        return {
          desiredSize: new go.Size(20, 20),
          fill: "White",
          strokeWidth: 0,
          fromSpot: go.Spot.Right, //no need for this, tree layout makes that for nodes automatically
          fromLinkable: !input,
          toSpot: go.Spot.Left,
          toLinkable: input,
          toMaxLinks: 1,
          fromMaxLinks: 1,
          cursor: "pointer"
        };
      }

      // define templates for each type of node
      var assignTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(orangegrad,"ASSIGN"));
      var printTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(orangegrad,"PRINT"));
      var plusTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(yellowgrad,"+"));
      var varsTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(bluegrad,"VARS"));
      var ifTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(greengrad,"IF"));
      var whileTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(greengrad,"WHILE"));
      var forTemplate =
        $(go.Node, "Spot", nodeFunctionStyle(greengrad,"FOR"));

      var argTemplate = 
        $(go.Panel,"Auto",
          $(go.Shape, "Rectangle", node_Var_ShapeStyle()),
          $(go.Shape, "Rectangle", portStyle(false),  // the rvalue port
            new go.Binding("portId", "portId"),
            { alignment: go.Spot.Right, alignmentFocus: go.Spot.Right ,opacity: 0.3}
          ),
          $(go.TextBlock, {editable: true},
            new go.Binding("text", "portId")
          )
        );

      var argsTemplate = 
        $(go.Node,"Vertical", nodeStyle(), 
          $(go.Panel, "Vertical",
            new go.Binding("itemArray","items"),
            {
              itemTemplate: argTemplate
            }
          ),
          $(go.Panel, "Horizontal",
            {alignment: go.Spot.Left},
            $("Button",
              $(go.Shape, "PlusLine", { width: 10, height: 10 }),
              {
                name: "BUTTON", 
                click: (e, button) => addArg(button.part)
              },
            ),
            $("Button",
              $(go.Shape, "MinusLine", { width: 10, height: 10 }),
              { 
                name: "BUTTON2", 
                click: (e, button) => removeArg(button.part)
              }
            )   
          )
        );

      function addArg(arg) {
        myDiagram.startTransaction("add argument");
        if (!(arg instanceof go.Node)) return;
        let i = 1;
        while (arg.findPort( i.toString() +":") !== arg) 
        {
          i++;
        }
        console.log(i);
        const name = i.toString()+":";
        const arr = arg.data.items;

        if (arr) {
          // create a new port data object
          const newportdata = {
            portId: name
          };
          // and add it to the end of Array of port data
          myDiagram.model.insertArrayItem(arr, -1, newportdata);
        }
        myDiagram.commitTransaction("add argument");
      }

      function removeArg(arg) {
        if (!arg) return;
        var arr = arg.data.items;
        myDiagram.startTransaction("remove argument");
        myDiagram.model.removeArrayItem(arr);
        myDiagram.commitTransaction("remove argument");
      }

      var blocksTemplate = 
        $(go.Node,"Spot", nodeStyle(), 
          {name: "blocks"},
          $(go.Panel, "Vertical",
            new go.Binding("itemArray","items"),
            {
              itemTemplate: 
                $(go.Panel,"Auto",
                  $(go.Shape, "Rectangle", portStyle(false),  // the rvalue port
                    new go.Binding("portId", "portId"),
                    {desiredSize: new go.Size(40, 40), strokeWidth: 2, fill: whitegrad}
                  ),
                  $(go.TextBlock,{editable: true},
                    new go.Binding("text", "portId")
                  )          
                )
            }
          ),
          $(go.Shape, "TriangleRight", portStyle(true),
            {
              portId: "in",
              desiredSize: new go.Size(20, 20),
              fill: "black",
              stroke: "blue", strokeWidth: 3,
              alignment: go.Spot.TopLeft
            }
          ),
          $(go.Shape, "Rectangle", 
            {
              desiredSize: new go.Size(20, 20),
              fill: "white",
              strokeWidth: 3,
              alignment: go.Spot.Top, alignmentFocus: go.Spot.Bottom
            }
          ),
          $(go.Panel, "Horizontal",
            {alignment: go.Spot.Bottom},
            $("Button",
              $(go.Shape, "PlusLine", { width: 10, height: 10 }),
              {
                name: "BUTTON", 
                click: (e, button) => addBlock(button.part)
              },
            ),
            $("Button",
              $(go.Shape, "MinusLine", { width: 10, height: 10 }),
              { 
                name: "BUTTON2", 
                click: (e, button) => removeBlock(button.part)
              },
            )   
          )   
        );
          
      function addBlock(block) {
        myDiagram.startTransaction("add block");
        if (!(block instanceof go.Node)) return;
        let i = 1;
        while (block.findPort( i.toString()) !== block) 
        {
          i++;
        }
        console.log(i);
        const name = i.toString();
        const arr = block.data.items;

        if (arr) {
          // create a new port data object
          const newportdata = {
            portId: name
          };
          // and add it to the end of Array of port data
          myDiagram.model.insertArrayItem(arr, -1, newportdata);
        }

        myDiagram.commitTransaction("add block");
      }

      function removeBlock(block) {
        if (!block) return;
        var arr = block.data.items;
        myDiagram.startTransaction("remove block");
        myDiagram.model.removeArrayItem(arr);
        myDiagram.commitTransaction("remove block");
      }

      // add the templates created above to myDiagram and myPalette
      myDiagram.nodeTemplateMap.add("assign", assignTemplate);
      myDiagram.nodeTemplateMap.add("print", printTemplate);
      myDiagram.nodeTemplateMap.add("plus", plusTemplate);
      myDiagram.nodeTemplateMap.add("vars", varsTemplate);
      myDiagram.nodeTemplateMap.add("if", ifTemplate);
      myDiagram.nodeTemplateMap.add("while", whileTemplate);
      myDiagram.nodeTemplateMap.add("for", forTemplate);
      myDiagram.nodeTemplateMap.add("args", argsTemplate);
      myDiagram.nodeTemplateMap.add("blocks", blocksTemplate);

      var assignGroupTemplate = 
        $(go.Group, groupFunctionStyle(orangegrad,"ASSIGN"));
      var printGroupTemplate = 
        $(go.Group, groupFunctionStyle(orangegrad,"PRINT"));
      var plusGroupTemplate = 
        $(go.Group, groupFunctionStyle(yellowgrad,"+"));
      var varsGroupTemplate = 
        $(go.Group, groupFunctionStyle(bluegrad,"VARS"));
      var ifGroupTemplate = 
        $(go.Group, groupFunctionStyle(greengrad,"IF"));
      var whileGroupTemplate = 
        $(go.Group, groupFunctionStyle(greengrad,"WHILE"));
      var forGroupTemplate = 
        $(go.Group, groupFunctionStyle(greengrad,"FOR"));

      myDiagram.groupTemplateMap.add("assignGroup", assignGroupTemplate);
      myDiagram.groupTemplateMap.add("printGroup", printGroupTemplate);
      myDiagram.groupTemplateMap.add("plusGroup", plusGroupTemplate);
      myDiagram.groupTemplateMap.add("varsGroup", varsGroupTemplate);
      myDiagram.groupTemplateMap.add("ifGroup", ifGroupTemplate);
      myDiagram.groupTemplateMap.add("whileGroup", whileGroupTemplate);
      myDiagram.groupTemplateMap.add("forGroup", forGroupTemplate);

      myDiagram.addDiagramListener("ExternalObjectsDropped", e => {
        // stop any ongoing text editing
        if (myDiagram.currentTool instanceof go.TextEditingTool) {
          myDiagram.currentTool.acceptText(go.TextEditingTool.LostFocus);
        }
        // expand any "macros"
        myDiagram.commandHandler.ungroupSelection();
        // start editing the first node that was dropped after ungrouping
        var tb = myDiagram.selection.first().findObject('TEXT');
        if (tb) myDiagram.commandHandler.editTextBlock(tb);
      });

      myDiagram.layout =  $(go.LayeredDigraphLayout,
              { direction: 0 })

      myPalette =  $(go.Palette, "myPaletteDiv",  // must name or refer to the DIV HTML element
        {
          nodeTemplateMap: myDiagram.nodeTemplateMap,  // share the templates used by myDiagram
          groupTemplateMap: myDiagram.groupTemplateMap,
          autoScale: go.Diagram.Uniform,

          model: new go.GraphLinksModel([  // specify the contents of the Palette
            //{category: "args", items: [ {portId: "lvalue"}, {portId: "rvalue"} ]},

            {key: "assignGroupKey", category: "assignGroup", text: "ASSIGN", isGroup: true},
            {key: "assignFunction",category: "assign", text: "ASSIGN", group: "assignGroupKey"},
            {key: "assignArguments", category: "args", items: [ 
              {portId: "lvalue:"},
              {portId: "rvalue:"} 
            ], group: "assignGroupKey"},


            {key: "printGroupKey", category: "printGroup", text: "PRINT", isGroup: true},
            {key: "printFunction",category: "print", text: "PRINT", group: "printGroupKey"},
            {key: "printArguments", category: "args", items: [ 
              {portId: "1:"},
              {portId: "2:"} 
            ], group: "printGroupKey"},


            {key: "plusGroupKey", category: "plusGroup", text: "PLUS", isGroup: true},
            {key: "plusFunction",category: "plus", text: "+", group: "plusGroupKey"},
            {key: "plusArguments", category: "args", items: [ 
              {portId: "lhs:"},
              {portId: "rhs:"} 
            ], group: "plusGroupKey"},


            {key: "varsGroupKey", category: "varsGroup", text: "VARS", isGroup: true},
            {key: "varsFunction",category: "vars", text: "VARS", group: "varsGroupKey"},
            {key: "varsArguments", category: "args", items: [ 
              {portId: "1:"},
              {portId: "2:"} 
            ], group: "varsGroupKey"},


            {key: "ifGroupKey", category: "ifGroup", text: "IF", isGroup: true},
            {key: "ifFunction",category: "if", text: "IF", group: "ifGroupKey"},
            {key: "ifArguments", category: "args", items: [ 
              {portId: "condition:"},
              {portId: "if_part:"},
              {portId: "else_part:"}, 
            ], group: "ifGroupKey"},


            {key: "whileGroupKey", category: "whileGroup", text: "WHILE", isGroup: true},
            {key: "whileFunction",category: "while", text: "WHILE", group: "whileGroupKey"},
            {key: "whileArguments", category: "args", items: [ 
              {portId: "condition:"},
              {portId: "if_true_part:"} 
            ], group: "whileGroupKey"},


            {key: "forGroupKey", category: "forGroup", text: "FOR", isGroup: true},
            {key: "forFunction",category: "for", text: "FOR", group: "forGroupKey"},
            {key: "forArguments", category: "args", items: [ 
              {portId: "initialize:"},
              {portId: "condition:"},
              {portId: "update:"},
              {portId: "contains:"},
            ], group: "forGroupKey"},


            { category: "blocks", items: [ {portId: "1"}, {portId: "2"} ]}
          ],
          [
            { category: "Reversed", from: "assignFunction", to: "assignArguments"},
            { category: "Reversed", from: "printFunction", to: "printArguments"},
            { category: "Reversed", from: "plusFunction", to: "plusArguments"},
            { category: "Reversed", from: "varsFunction", to: "varsArguments"},
            { category: "Reversed", from: "ifFunction", to: "ifArguments"},
            { category: "Reversed", from: "whileFunction", to: "whileArguments"},
            { category: "Reversed", from: "forFunction", to: "forArguments"},
          ]
          )
        });  // create a new Palette in the HTML DIV element "palette"

      // load the initial diagram
      load();
    }

    // save a model to and load a model from JSON text, displayed below the Diagram
    function save() {
      document.getElementById("mySavedModel").value = myDiagram.model.toJson();
      myDiagram.isModified = false;

      generate(document.getElementById("mySavedModel").value);
    }
    function load() {
      myDiagram.model = go.Model.fromJson(document.getElementById("mySavedModel").value);
    }
  </script>
  </head>

  <body onload="init()">
    <div id="sample">
    <div style="width: 100%; display: flex; justify-content: space-between">
      <div id="myPaletteDiv" style="width: 120px; height: 500px; margin-right: 2px; background-color: whitesmoke; border: 1px solid black; position: relative;"></div>
      <div id="myDiagramDiv" style="flex-grow: 1; height: 500px; border: 1px solid black; position: relative;"></div>
    </div>
    <div>
      <div>
        <button id="saveModel" onclick="save()">Save</button>
        <button onclick="load()">Load</button>
        Diagram Model saved in JSON format:
      </div>
      <textarea id="mySavedModel" style="width:48%;height:200px; margin-right: 5px;" >
      { 
        "class": "go.GraphLinksModel",
        "copiesArrays": true,
        "copiesArrayObjects": true,
        "linkFromPortIdProperty": "fromPort",
        "linkToPortIdProperty": "toPort",
        "nodeDataArray": [
        ],
        "linkDataArray": [
        ]
      }
      </textarea>
      <textarea id="generatedModel" style="flex-grow: 1; width:48%;height:200px">
      </textarea>
    </div>
    </pre></div>
    
  </body>
  </html>